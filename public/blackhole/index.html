<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: white;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }

        .controls {
            position: fixed;
            top: 120px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 0, 0.6);
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3);
            backdrop-filter: blur(20px);
            font-size: 12px;
            width: 320px;
            max-height: 70vh;
            overflow-y: auto;
            z-index: 1000;
            transition: opacity 0.3s ease;
            cursor: move;
            user-select: none;
        }

        /* Mobile responsive controls */
        @media (max-width: 768px) {
            .controls {
                top: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                max-width: none;
                padding: 20px 15px;
                font-size: 16px;
                max-height: 75vh;
                border-radius: 12px;
                backdrop-filter: blur(25px);
                background: rgba(0, 0, 0, 0.95);
                border: 2px solid rgba(255, 255, 0, 0.8);
                box-shadow: 0 0 20px rgba(255, 255, 0, 0.4);
            }
            
            .control-group {
                margin-bottom: 20px;
            }
            
            .control-group h3 {
                font-size: 16px;
                margin-bottom: 12px;
                text-align: center;
                padding-bottom: 8px;
            }
            
            .control-item {
                margin-bottom: 15px;
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .control-item label {
                min-width: auto;
                font-size: 14px;
                font-weight: bold;
                text-align: center;
                color: #ffff00;
            }
            
            .control-item input[type="range"] {
                width: 100%;
                height: 8px;
                background: rgba(255, 255, 255, 0.3);
                border-radius: 4px;
            }
            
            .control-item input[type="range"]::-webkit-slider-thumb {
                width: 20px;
                height: 20px;
                background: #ffff00;
                border-radius: 50%;
                cursor: pointer;
                box-shadow: 0 0 10px rgba(255, 255, 0, 0.6);
            }
            
            .control-item input[type="checkbox"] {
                width: 20px;
                height: 20px;
                align-self: center;
            }
            
            .control-item .value {
                font-size: 14px;
                font-weight: bold;
                text-align: center;
                color: #ffff00;
                background: rgba(255, 255, 0, 0.1);
                padding: 4px 8px;
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 0, 0.3);
            }
        }
        
        /* Tablet responsive controls */
        @media (min-width: 769px) and (max-width: 1024px) {
            .controls {
                width: 350px;
                max-height: 75vh;
                font-size: 13px;
            }
            
            .control-item label {
                min-width: 150px;
                font-size: 12px;
            }
            
            .control-item input[type="range"] {
                width: 130px;
            }
        }

        .controls.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group h3 {
            color: #ffff00;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: bold;
            border-bottom: 1px solid rgba(255, 255, 0, 0.4);
            padding-bottom: 4px;
            cursor: default;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            cursor: default;
        }

        .control-item label {
            color: #ddd;
            font-size: 11px;
            font-weight: 500;
            min-width: 120px;
        }

        .control-item input[type="range"] {
            width: 100px;
            height: 5px;
            background: rgba(255, 255, 255, 0.25);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #ffff00;
            border-radius: 50%;
            cursor: pointer;
        }

        .control-item input[type="checkbox"] {
            width: 14px;
            height: 14px;
            accent-color: #ffff00;
            cursor: pointer;
        }

        .control-item .value {
            color: #ffff00;
            font-size: 10px;
            font-weight: bold;
            min-width: 45px;
            text-align: right;
        }


        /* Instructions removed - using React overlay */

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2000;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 53, 0.3);
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 107, 53, 0.3);
            border-top: 3px solid #ff6b35;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>


    <div class="controls hidden" id="controlPanel">
        <div class="control-group">
            <h3>Black Hole</h3>
            <div class="control-item">
                <label>Gravitational Lensing</label>
                <input type="checkbox" id="gravatationalLensing" checked onchange="updateParam(this)">
            </div>
            <div class="control-item">
                <label>Render Black Hole</label>
                <input type="checkbox" id="renderBlackHole" checked onchange="updateParam(this)">
            </div>
            <div class="control-item">
                <label>Mouse Control</label>
                <input type="checkbox" id="mouseControl" checked onchange="updateParam(this)">
            </div>
            <div class="control-item">
                <label>Camera Roll</label>
                <input type="range" id="cameraRoll" min="-180" max="180" value="0" step="1" oninput="updateParam(this)">
                <span class="value" id="cameraRoll_value">0Â°</span>
            </div>
        </div>

        <div class="control-group">
            <h3>Accretion Disk</h3>
            <div class="control-item">
                <label>Enable Disk</label>
                <input type="checkbox" id="adiskEnabled" checked onchange="updateParam(this)">
            </div>
            <div class="control-item">
                <label>Particle Mode</label>
                <input type="checkbox" id="adiskParticle" checked onchange="updateParam(this)">
            </div>
            <div class="control-item">
                <label>Density Vertical</label>
                <input type="range" id="adiskDensityV" min="0" max="10" value="3" step="0.1" oninput="updateParam(this)">
                <span class="value" id="adiskDensityV_value">3.0</span>
            </div>
            <div class="control-item">
                <label>Density Horizontal</label>
                <input type="range" id="adiskDensityH" min="0" max="10" value="2.5" step="0.1" oninput="updateParam(this)">
                <span class="value" id="adiskDensityH_value">2.5</span>
            </div>
            <div class="control-item">
                <label>Disk Height</label>
                <input type="range" id="adiskHeight" min="0" max="1" value="0.3" step="0.01" oninput="updateParam(this)">
                <span class="value" id="adiskHeight_value">0.30</span>
            </div>
            <div class="control-item">
                <label>Lighting</label>
                <input type="range" id="adiskLit" min="0" max="4" value="0.4" step="0.01" oninput="updateParam(this)">
                <span class="value" id="adiskLit_value">0.40</span>
            </div>
            <div class="control-item">
                <label>Noise Scale</label>
                <input type="range" id="adiskNoiseScale" min="0" max="10" value="1.2" step="0.1" oninput="updateParam(this)">
                <span class="value" id="adiskNoiseScale_value">1.2</span>
            </div>
            <div class="control-item">
                <label>Noise Detail</label>
                <input type="range" id="adiskNoiseLOD" min="1" max="12" value="7" step="1" oninput="updateParam(this)">
                <span class="value" id="adiskNoiseLOD_value">7</span>
            </div>
            <div class="control-item">
                <label>Rotation Speed</label>
                <input type="range" id="adiskSpeed" min="0" max="1" value="0.3" step="0.01" oninput="updateParam(this)">
                <span class="value" id="adiskSpeed_value">0.30</span>
            </div>
        </div>

        <div class="control-group">
            <h3>Post-Processing</h3>
            <div class="control-item">
                <label>Bloom Strength</label>
                <input type="range" id="bloomStrength" min="0" max="1" value="0.15" step="0.01" oninput="updateParam(this)">
                <span class="value" id="bloomStrength_value">0.15</span>
            </div>
            <div class="control-item">
                <label>Tone Mapping</label>
                <input type="checkbox" id="tonemappingEnabled" checked onchange="updateParam(this)">
            </div>
            <div class="control-item">
                <label>Gamma</label>
                <input type="range" id="gamma" min="1" max="4" value="1" step="0.1" oninput="updateParam(this)">
                <span class="value" id="gamma_value">1.0</span>
            </div>
        </div>

        <div class="control-group">
            <h3>Camera</h3>
            <div class="control-item">
                <label>Zoom Level</label>
                <input type="range" id="zoomLevel" min="0.1" max="5" value="1" step="0.1" oninput="updateParam(this)">
                <span class="value" id="zoomLevel_value">1.0</span>
            </div>
            <div class="control-item">
                <label>Front View</label>
                <input type="checkbox" id="frontView" onchange="updateParam(this)">
            </div>
            <div class="control-item">
                <label>Top View</label>
                <input type="checkbox" id="topView" onchange="updateParam(this)">
            </div>
        </div>
    </div>

    <!-- Instructions removed - using React overlay -->

    <!-- Load all the JavaScript modules -->
    <script src="/blackhole/webgl_fix.js"></script>
    <script src="/blackhole/main_loop_fix.js"></script>
    <script src="/blackhole/blackhole_js.js"></script>

    <script>
        let simulation = null;
        let controlsVisible = false; // Start with controls hidden

        // Initialize the simulation
        async function init() {
            const canvas = document.getElementById('canvas');
            
            // Set canvas size to full window
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                if (simulation && simulation.initialized) {
                    simulation.canvas.width = canvas.width;
                    simulation.canvas.height = canvas.height;
                }
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Create and initialize simulation
            simulation = new BlackHoleSimulation(canvas);
            
            try {
                const success = await simulation.init();
                if (success) {
                    simulation.start();
                    console.log('ðŸŒŸ Black hole simulation ready!');
                    
                    // Add mouse wheel zoom
                    setupZoomControl();
                } else {
                    console.error('âŒ Failed to initialize simulation');
                }
            } catch (error) {
                console.error('âŒ Simulation error:', error);
            }
        }

        // Setup mouse wheel zoom control
        function setupZoomControl() {
            let zoomLevel = 1.0;
            
            simulation.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const zoomSpeed = 0.1;
                const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
                zoomLevel = Math.max(0.1, Math.min(5.0, zoomLevel + delta));
                
                // Update the slider
                document.getElementById('zoomLevel').value = zoomLevel;
                document.getElementById('zoomLevel_value').textContent = zoomLevel.toFixed(1);
                
                // Update simulation parameter
                if (simulation && simulation.params) {
                    simulation.params.fovScale = 1.0 / zoomLevel;
                }
            });
        }

        // Update simulation parameters from controls
        function updateParam(element) {
            if (!simulation || !simulation.params) return;
            
            const id = element.id;
            let value;
            
            if (element.type === 'checkbox') {
                value = element.checked ? 1.0 : 0.0;
            } else if (element.type === 'range') {
                value = parseFloat(element.value);
                // Update value display
                const valueSpan = document.getElementById(id + '_value');
                if (valueSpan) {
                    if (id === 'cameraRoll') {
                        valueSpan.textContent = value + 'Â°';
                    } else {
                        valueSpan.textContent = value.toFixed(2);
                    }
                }
            }
            
            // Special handling for zoom
            if (id === 'zoomLevel') {
                simulation.params.fovScale = 1.0 / value;
            } else {
                simulation.params[id] = value;
            }
        }

        // Toggle control panel for double-tap
        function toggleControlPanel() {
            const panel = document.getElementById('controlPanel');
            controlsVisible = !controlsVisible;
            
            if (controlsVisible) {
                panel.classList.remove('hidden');
            } else {
                panel.classList.add('hidden');
            }
        }

        // Make control panel draggable
        function makeDraggable() {
            const controlPanel = document.getElementById('controlPanel');
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            controlPanel.addEventListener('mousedown', (e) => {
                // Only start drag if clicking on the panel background or headers, not controls
                if (e.target === controlPanel || e.target.tagName === 'H3') {
                    isDragging = true;
                    const rect = controlPanel.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    controlPanel.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const x = Math.max(0, Math.min(window.innerWidth - controlPanel.offsetWidth, e.clientX - dragOffset.x));
                    const y = Math.max(0, Math.min(window.innerHeight - controlPanel.offsetHeight, e.clientY - dragOffset.y));
                    
                    controlPanel.style.left = x + 'px';
                    controlPanel.style.top = y + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    controlPanel.style.cursor = 'move';
                }
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'h':
                    toggleControlPanel();
                    break;
                case 'f':
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.documentElement.requestFullscreen();
                    }
                    break;
            }
        });

        // Mobile detection and touch controls
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                        (window.innerWidth <= 768) ||
                        ('ontouchstart' in window);

        // Enhanced mobile touch controls with smooth camera rotation
        if (isMobile) {
            let lastTouchTime = 0;
            let initialDistance = null;
            let initialZoom = 1.0;
            let isDragging = false;
            let lastTouchX = 0;
            let lastTouchY = 0;
            let currentMouseX = 0.5; // Start at center
            let currentMouseY = 0.5; // Start at center
            const canvas = document.getElementById('canvas');
            
            // Function to calculate distance between two touch points
            function getDistance(touch1, touch2) {
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // Enhanced touch start - handle both single finger drag and pinch
            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                    // Single finger - prepare for camera rotation
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    lastTouchX = touch.clientX - rect.left;
                    lastTouchY = touch.clientY - rect.top;
                    isDragging = false; // Will be set to true on move
                } else if (e.touches.length === 2) {
                    // Two fingers down - start pinch gesture
                    e.preventDefault();
                    isDragging = false; // Disable drag when pinching
                    initialDistance = getDistance(e.touches[0], e.touches[1]);
                    initialZoom = parseFloat(document.getElementById('zoomLevel').value) || 1.0;
                }
            });
            
            // Enhanced touch move - handle both smooth camera rotation and pinch zoom
            canvas.addEventListener('touchmove', function(e) {
                if (e.touches.length === 1 && simulation) {
                    // Single finger drag - smooth camera rotation
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const currentX = touch.clientX - rect.left;
                    const currentY = touch.clientY - rect.top;
                    
                    // Calculate movement delta
                    const deltaX = currentX - lastTouchX;
                    const deltaY = currentY - lastTouchY;
                    
                    // Only start dragging if there's significant movement
                    if (!isDragging && (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3)) {
                        isDragging = true;
                        e.preventDefault();
                    }
                    
                    if (isDragging) {
                        e.preventDefault();
                        
                        // Smooth camera rotation using delta movement
                        if (simulation && simulation.params && simulation.params.mouseControl > 0) {
                            // Sensitivity factor for smooth rotation
                            const sensitivity = 0.002;
                            
                            // Update mouse position based on delta movement
                            currentMouseX += deltaX * sensitivity;
                            currentMouseY -= deltaY * sensitivity; // Invert Y for natural feel
                            
                            // Keep within bounds (wrap around for smooth continuous rotation)
                            currentMouseX = Math.max(0, Math.min(1, currentMouseX));
                            currentMouseY = Math.max(0, Math.min(1, currentMouseY));
                            
                            // Apply to simulation
                            simulation.mouseX = currentMouseX;
                            simulation.mouseY = currentMouseY;
                        }
                        
                        lastTouchX = currentX;
                        lastTouchY = currentY;
                    }
                } else if (e.touches.length === 2 && initialDistance !== null) {
                    // Two finger pinch - zoom control
                    e.preventDefault();
                    
                    const currentDistance = getDistance(e.touches[0], e.touches[1]);
                    const scale = currentDistance / initialDistance;
                    let newZoom = initialZoom * scale;
                    
                    // Constrain zoom level
                    newZoom = Math.max(0.1, Math.min(5.0, newZoom));
                    
                    // Update the zoom slider and simulation
                    const zoomSlider = document.getElementById('zoomLevel');
                    const zoomValue = document.getElementById('zoomLevel_value');
                    
                    if (zoomSlider && zoomValue) {
                        zoomSlider.value = newZoom;
                        zoomValue.textContent = newZoom.toFixed(1);
                        
                        // Update simulation parameter
                        if (simulation && simulation.params) {
                            simulation.params.fovScale = 1.0 / newZoom;
                        }
                    }
                }
            });
            
            // Enhanced touch end - handle drag end, pinch end, and double-tap
            canvas.addEventListener('touchend', function(e) {
                if (e.touches.length < 2) {
                    initialDistance = null;
                }
                
                // If we were dragging, don't process double-tap
                if (isDragging) {
                    isDragging = false;
                    return;
                }
                
                // Double-tap detection (only if not dragging and not in a pinch gesture)
                if (e.touches.length === 0 && initialDistance === null) {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTouchTime;
                    
                    if (tapLength < 500 && tapLength > 0) {
                        // Double tap detected
                        e.preventDefault();
                        toggleControlPanel();
                    }
                    lastTouchTime = currentTime;
                }
            });
            
            // Prevent default touch behaviors for multi-touch
            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            canvas.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        // Initialize draggable functionality
        makeDraggable();

        // Start the simulation
        init();
    </script>
</body>
</html>
